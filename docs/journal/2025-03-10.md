# ğŸ“… 2025-02-25 - VÃ½zkum a implementace algoritmÅ¯ pro kompresi stromovÃ½ch struktur

Dnes jsem se zamÄ›Å™il na implementaci a vÃ½zkum rÅ¯znÃ½ch existujÃ­cÃ­ch algoritmÅ¯ pro kompresi stromovÃ½ch struktur. Prozkoumal jsem tÅ™i hlavnÃ­ algoritmy: **DictionaryTreeCompression**, **FrequentSubtreeCompression** a **RePairTreeCompressor**. KaÅ¾dÃ½ z tÄ›chto algoritmÅ¯ mÃ¡ svÃ© vÃ½hody a specifickÃ© vyuÅ¾itÃ­ v zÃ¡vislosti na druhu dat, kterÃ¡ se komprimujÃ­. Tento vÃ½zkum mi pomohl lÃ©pe pochopit, jak kaÅ¾dÃ½ z tÄ›chto pÅ™Ã­stupÅ¯ funguje a jak je moÅ¾nÃ© je vyuÅ¾Ã­t pro optimalizaci komprese stromÅ¯ ve svÃ©m projektu.

## ğŸ“š Algoritmy pro kompresi stromovÃ½ch struktur

### 1. **DictionaryTreeCompression** 
Tento algoritmus je znÃ¡mÃ½ svou efektivitou pÅ™i kompresi dat ve stromovÃ½ch strukturÃ¡ch, pÅ™iÄemÅ¾ je bÄ›Å¾nÄ› pouÅ¾Ã­vÃ¡n pro **kompresi XML dat** a dalÅ¡Ã­ch hierarchickÃ½ch datovÃ½ch formÃ¡tÅ¯. Funguje tak, Å¾e vytvÃ¡Å™Ã­ slovnÃ­k, kterÃ½ obsahuje opakujÃ­cÃ­ se podstromy. KaÅ¾dÃ½ podstrom je reprezentovÃ¡n klÃ­Äem ve slovnÃ­ku, coÅ¾ umoÅ¾Åˆuje kompresi tÃ­m, Å¾e mÃ­sto opakovanÃ½ch podstromÅ¯ se pouÅ¾Ã­vÃ¡ pouze jejich klÃ­Ä. Tento pÅ™Ã­stup vÃ½raznÄ› sniÅ¾uje velikost dat, zejmÃ©na pokud existujÃ­ rekurentnÃ­ vzory.

**MoÅ¾nosti vyuÅ¾itÃ­:**
- Tento algoritmus bych mohl pouÅ¾Ã­t pro kompresi stromovÃ½ch struktur, kterÃ© vykazujÃ­ vysokou mÃ­ru opakovÃ¡nÃ­ v jejich podstrukturoch.
- V budoucnu by se mohl ukÃ¡zat jako efektivnÃ­ pro kompresi syntaktickÃ½ch stromÅ¯, pokud se budou vyskytovat opakujÃ­cÃ­ se vzory, napÅ™Ã­klad v dlouhÃ½ch vÄ›tÃ¡ch nebo textovÃ½ch blocÃ­ch.

### 2. **FrequentSubtreeCompression**
Tento algoritmus se zamÄ›Å™uje na **kompresi ÄastÃ½ch podstromÅ¯**, coÅ¾ znamenÃ¡, Å¾e hledÃ¡ podstromy, kterÃ© se vyskytujÃ­ Äasto v celÃ©m stromu, a nahrazuje je jedineÄnÃ½mi identifikÃ¡tory. Tento pÅ™Ã­stup je Äasto pouÅ¾Ã­vÃ¡n v **bioinformatice** pro kompresi dat, jako jsou filogenetickÃ© stromy, a v dalÅ¡Ã­ch oblastech, kde se Äasto opakujÃ­ urÄitÃ© struktury.

**MoÅ¾nosti vyuÅ¾itÃ­:**
- Tento algoritmus by mohl bÃ½t uÅ¾iteÄnÃ½, pokud budu pracovat s rozsÃ¡hlÃ½mi daty, kde nÄ›kterÃ© podstromy nebo vzory struktury stromu mohou bÃ½t velmi ÄastÃ©.
- V budoucnu se ukÃ¡Å¾e jako vhodnÃ½ pro kompresi sloÅ¾itÄ›jÅ¡Ã­ch stromovÃ½ch struktur s vysokou mÃ­rou opakovÃ¡nÃ­, coÅ¾ je typickÃ© pro texty s mnoha podobnÃ½mi vÄ›tami.

### 3. **RePairTreeCompressor**
**RePair** je algoritmus, kterÃ½ se zamÄ›Å™uje na **nalezenÃ­ opakujÃ­cÃ­ch se vzorcÅ¯** v datech a jejich nahrazenÃ­ symboly, coÅ¾ vede k vÃ½raznÃ© redukci velikosti. Tento algoritmus je oblÃ­benÃ½ pro kompresi textÅ¯ a **XML dat** a je znÃ¡mÃ½ svou efektivitou pÅ™i hledÃ¡nÃ­ a nahrazovÃ¡nÃ­ opakujÃ­cÃ­ch se podstruktur.

**MoÅ¾nosti vyuÅ¾itÃ­:**
- RePair je vhodnÃ½ pro situace, kdy je potÅ™eba efektivnÄ› komprimovat velkÃ© mnoÅ¾stvÃ­ dat, a to zejmÃ©na kdyÅ¾ se v datech nachÃ¡zÃ­ podobnÃ© podstruktury.
- Tento algoritmus by mohl bÃ½t jednÃ­m z klÃ­ÄovÃ½ch nÃ¡strojÅ¯ pro mojÃ­ implementaci kompresnÃ­ho algoritmu, zejmÃ©na pokud budu mÃ­t problÃ©m s velkÃ½m mnoÅ¾stvÃ­m opakujÃ­cÃ­ch se vzorcÅ¯ v syntaktickÃ½ch stromech.

## ğŸ› ï¸ Implementace a experimenty

V rÃ¡mci implementace jsem se nejprve zamÄ›Å™il na zÃ¡kladnÃ­ verzi kaÅ¾dÃ©ho algoritmu:

- **DictionaryTreeCompression**: ZaÄal jsem implementacÃ­ jednoduchÃ©ho slovnÃ­ku pro uklÃ¡dÃ¡nÃ­ opakujÃ­cÃ­ch se podstromÅ¯. Testoval jsem ho na nÄ›kolika pÅ™Ã­kladech textu, kde jsem hledal opakujÃ­cÃ­ se frÃ¡ze.
  
- **FrequentSubtreeCompression**: Tento algoritmus jsem implementoval tak, Å¾e jsem prohledÃ¡val strom a identifikoval podstromy, kterÃ© se vyskytovaly ÄastÄ›ji neÅ¾ ostatnÃ­. Tyto podstromy jsem nahradil identifikÃ¡tory.

- **RePairTreeCompressor**: Tento algoritmus jsem implementoval s vyuÅ¾itÃ­m principu iterativnÃ­ komprese, kde se v kaÅ¾dÃ© iteraci hledajÃ­ a nahrazujÃ­ opakujÃ­cÃ­ se vzory. Implementace vyÅ¾adovala dostateÄnÄ› efektivnÃ­ zpÅ¯sob, jak zpracovÃ¡vat a uklÃ¡dat nalezenÃ© vzory.

## ğŸš€ VÃ½sledky a zhodnocenÃ­

BÄ›hem implementace jsem se hodnÄ› nauÄil o tÄ›chto algoritmech a jejich vÃ½hodÃ¡ch:

- **DictionaryTreeCompression** se osvÄ›dÄil jako efektivnÃ­ pro kompresi textovÃ½ch stromÅ¯, ale je mÃ©nÄ› efektivnÃ­ pÅ™i zpracovÃ¡nÃ­ stromÅ¯ s niÅ¾Å¡Ã­mi mÃ­rami opakovÃ¡nÃ­.
- **FrequentSubtreeCompression** je velmi silnÃ½ pÅ™i kompresi dat, kde se vyskytujÃ­ ÄastÃ© vzory. MÅ¯Å¾e bÃ½t uÅ¾iteÄnÃ½ pro struktury s vÃ½raznÃ½m opakovÃ¡nÃ­m.
- **RePairTreeCompressor** se ukÃ¡zal jako nejlepÅ¡Ã­ pro moji aplikaci, protoÅ¾e je schopnÃ½ najÃ­t opakujÃ­cÃ­ se vzory a komprimovat je velmi efektivnÄ›, zejmÃ©na u velkÃ½ch stromÅ¯.

### ğŸ’¡ Co dÃ¡l?
V budoucnu bych chtÄ›l:

- **Porovnat vÃ½kon** tÄ›chto algoritmÅ¯ na reÃ¡lnÃ½ch datech.
- **VytvoÅ™it hybridnÃ­ metodu**, kterÃ¡ by kombinovala vÃ½hody jednotlivÃ½ch algoritmÅ¯.
- **Testovat na vÄ›tÅ¡Ã­ch datech**, abych zjistil, jak se chovajÃ­ pÅ™i vyÅ¡Å¡Ã­ sloÅ¾itosti a vÄ›tÅ¡Ã­ velikosti stromu.

CelkovÄ› jsem se nauÄil hodnÄ› o tom, jak algoritmy pro kompresi stromÅ¯ fungujÃ­ a jak je lze aplikovat na rÅ¯znÃ© typy dat. ZatÃ­m se mi nejvÃ­ce osvÄ›dÄil **RePair**, ale stÃ¡le je prostor pro optimalizace a zlepÅ¡enÃ­.